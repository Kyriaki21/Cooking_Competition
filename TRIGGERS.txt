DELIMITER //

CREATE TRIGGER BeforeInsertParticipant
BEFORE INSERT ON Episode_has_Participants
FOR EACH ROW
BEGIN
    DECLARE consecutive_count INT DEFAULT 0;
    DECLARE curr_episode INT;
    DECLARE curr_season INT;
    DECLARE done INT DEFAULT FALSE;

    -- Declare cursor to iterate over the last three episodes in descending order
    DECLARE recent_episodes CURSOR FOR
        SELECT e.Episode_number, e.Season_number
        FROM Episode e
        LEFT JOIN Episode_has_Participants ep ON e.idEpisode = ep.Episode_idEpisode AND ep.Cook_idCook = NEW.Cook_idCook
        LEFT JOIN Episode_has_Judges ej ON e.idEpisode = ej.Episode_idEpisode AND ej.Judge_idJudge = NEW.Cook_idCook
        WHERE ep.Cook_idCook IS NOT NULL OR ej.Judge_idJudge IS NOT NULL
        ORDER BY e.Season_number DESC, e.Episode_number DESC
        LIMIT 3;

    -- Declare continue handler for cursor
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- Open the cursor
    OPEN recent_episodes;

    -- Fetch episodes and check for consecutive participation
    read_loop: LOOP
        FETCH recent_episodes INTO curr_episode, curr_season;
        IF done THEN
            LEAVE read_loop;
        END IF;

        -- Check if the current episode is consecutive
        IF curr_season = (SELECT Season_number FROM Episode WHERE idEpisode = NEW.Episode_idEpisode) AND
           curr_episode = (SELECT Episode_number FROM Episode WHERE idEpisode = NEW.Episode_idEpisode) - consecutive_count - 1 THEN
            SET consecutive_count = consecutive_count + 1;
        ELSE
            SET consecutive_count = 0;
        END IF;
    END LOOP;

    -- Close the cursor
    CLOSE recent_episodes;

    -- If the cook has participated in the last three consecutive episodes, signal an error
    IF consecutive_count >= 3 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'The cook cannot participate in more than three consecutive episodes.';
    END IF;
END //

DELIMITER ;

DELIMITER //

CREATE TRIGGER BeforeInsertJudge
BEFORE INSERT ON Episode_has_Judges
FOR EACH ROW
BEGIN
    DECLARE consecutive_count INT DEFAULT 0;
    DECLARE curr_episode INT;
    DECLARE curr_season INT;
    DECLARE done INT DEFAULT FALSE;

    -- Declare cursor to iterate over the last three episodes in descending order
    DECLARE recent_episodes CURSOR FOR
        SELECT e.Episode_number, e.Season_number
        FROM Episode e
        LEFT JOIN Episode_has_Participants ep ON e.idEpisode = ep.Episode_idEpisode AND ep.Cook_idCook = NEW.Judge_idJudge
        LEFT JOIN Episode_has_Judges ej ON e.idEpisode = ej.Episode_idEpisode AND ej.Judge_idJudge = NEW.Judge_idJudge
        WHERE ep.Cook_idCook IS NOT NULL OR ej.Judge_idJudge IS NOT NULL
        ORDER BY e.Season_number DESC, e.Episode_number DESC
        LIMIT 3;

    -- Declare continue handler for cursor
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- Open the cursor
    OPEN recent_episodes;

    -- Fetch episodes and check for consecutive participation
    read_loop: LOOP
        FETCH recent_episodes INTO curr_episode, curr_season;
        IF done THEN
            LEAVE read_loop;
        END IF;

        -- Check if the current episode is consecutive
        IF curr_season = (SELECT Season_number FROM Episode WHERE idEpisode = NEW.Episode_idEpisode) AND
           curr_episode = (SELECT Episode_number FROM Episode WHERE idEpisode = NEW.Episode_idEpisode) - consecutive_count - 1 THEN
            SET consecutive_count = consecutive_count + 1;
        ELSE
            SET consecutive_count = 0;
        END IF;
    END LOOP;

    -- Close the cursor
    CLOSE recent_episodes;

    -- If the cook has participated in the last three consecutive episodes, signal an error
    IF consecutive_count >= 3 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'The cook cannot participate in more than three consecutive episodes.';
    END IF;
END //

DELIMITER ;

DELIMITER //

CREATE TRIGGER BeforeUpdateIngredients
BEFORE UPDATE ON Ingredients
FOR EACH ROW
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE recipe_id INT;

    -- Cursor to iterate over recipes that use this ingredient
    DECLARE recipe_cursor CURSOR FOR 
        SELECT DISTINCT Recipe_idRecipe
        FROM Recipe_has_Ingredients
        WHERE Ingredients_idIngredients = OLD.idIngredients;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- Check if any of the nutritional values are being updated
    IF NEW.fat != OLD.fat OR
       NEW.protein != OLD.protein OR
       NEW.carbohydrate != OLD.carbohydrate OR
       NEW.calories != OLD.calories THEN

        OPEN recipe_cursor;
        
        read_loop: LOOP
            FETCH recipe_cursor INTO recipe_id;
            IF done THEN
                LEAVE read_loop;
            END IF;

            -- Recalculate nutritional values for the recipe
            CALL CalculateRecipeNutrition(recipe_id);
        END LOOP;

        CLOSE recipe_cursor;
    END IF;
END //

DELIMITER ;

DELIMITER //

-- Stored procedure to calculate nutritional values for a recipe
CREATE PROCEDURE CalculateRecipeNutrition(IN recipe_id INT)
BEGIN
    DECLARE total_calories DECIMAL(10,2) DEFAULT 0;
    DECLARE total_fat DECIMAL(10,2) DEFAULT 0;
    DECLARE total_protein DECIMAL(10,2) DEFAULT 0;
    DECLARE total_carbohydrate DECIMAL(10,2) DEFAULT 0;
    DECLARE total_weight DECIMAL(10,2) DEFAULT 0;
    DECLARE servings INT DEFAULT 1;
    DECLARE done INT DEFAULT FALSE;
    DECLARE ingredient_id INT;
    DECLARE quantity INT;

    -- Cursor to iterate over the ingredients of the recipe
    DECLARE ingredient_cursor CURSOR FOR 
        SELECT Ingredients_idIngredients, quantity
        FROM Recipe_has_Ingredients
        WHERE Recipe_idRecipe = recipe_id;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- Get the total number of servings for the recipe
    SELECT portions INTO servings
    FROM Recipe
    WHERE idRecipe = recipe_id;

    -- Open the cursor
    OPEN ingredient_cursor;

    -- Loop through the ingredients
    read_loop: LOOP
        FETCH ingredient_cursor INTO ingredient_id, quantity;
        IF done THEN
            LEAVE read_loop;
        END IF;

        -- Calculate total weight of ingredient in grams
        SET total_weight = quantity;

        -- Calculate calories, fat, protein, and carbohydrate per serving for each ingredient
        SELECT 
            (i.total_calories / 100 * total_weight) / servings AS calories,
            (i.total_fat / 100 * total_weight) / servings AS fat,
            (i.total_protein / 100 * total_weight) / servings AS protein,
            (i.total_carbohydrate / 100 * total_weight) / servings AS carbohydrate
        INTO 
            @calories_per_serving, @fat_per_serving, @protein_per_serving, @carbohydrate_per_serving
        FROM Ingredients i
        WHERE i.idIngredients = ingredient_id;

        -- Sum up total calories, fat, protein, and carbohydrate for the recipe
        SET total_calories = total_calories + @calories_per_serving;
        SET total_fat = total_fat + @fat_per_serving;
        SET total_protein = total_protein + @protein_per_serving;
        SET total_carbohydrate = total_carbohydrate + @carbohydrate_per_serving;
    END LOOP;

    -- Close the cursor
    CLOSE ingredient_cursor;

    -- Update recipe table with calculated nutritional information
    UPDATE Recipe
    SET total_calories = total_calories,
        total_fat = total_fat,
        total_protein = total_protein,
        total_carbohydrate = total_carbohydrate
    WHERE idRecipe = recipe_id;
END //

DELIMITER ;

-- Trigger to call the procedure after insert on Recipe_has_Ingredients
DELIMITER //

CREATE TRIGGER AfterInsertRecipeIngredient
AFTER INSERT ON Recipe_has_Ingredients
FOR EACH ROW
BEGIN
    CALL CalculateRecipeNutrition(NEW.Recipe_idRecipe);
END //

DELIMITER ;

DELIMITER //

-- Trigger to call the procedure after delete on Recipe_has_Ingredients
CREATE TRIGGER AfterDeleteRecipeIngredient
AFTER DELETE ON Recipe_has_Ingredients
FOR EACH ROW
BEGIN
    CALL CalculateRecipeNutrition(OLD.Recipe_idRecipe);
END //

DELIMITER ;

DELIMITER //

CREATE TRIGGER BeforeUpdateRecipeIngredient
BEFORE UPDATE ON Recipe_has_Ingredients
FOR EACH ROW
BEGIN
    IF NEW.Quantity != OLD.Quantity THEN
        CALL CalculateRecipeNutrition(OLD.Recipe_idRecipe);
    END IF;
END //

DELIMITER ;